Até agora, formalmente, definimos lógica de primeira ordem, onde iniciamoscom um estoque 
fixo de símbolos de funções e relações, nos últimos tópicos que  consideramos, ocorre a motivação 
de extender a linguagem para funções e relações. Por exemplo, ao afirmar que $f: X \to Y$ possui 
inversa a esquerda pode ser dito como: $$\exists g, \forall x, g(f(x)) = x.$$
Outro exemplo é o seguinte teorema, descrito em linguagem lógica 
$$\forall x_1, x_2, (f(x_1) = f(x_2) \to x_1 = x_2) \to \exists g, \forall x, g(f(x)) = x.$$
Isto é, se $f: X \to Y$ é injetiva, então existe inversa à sua esquerda.

Nesse sentido, existe uma quantificação sobre as funções e relações, o que se distancia do que a lógica 
de primeira ordem cobre. Como forma de resolver esse impasse, podemos desenvolver uma teoria na linguagem 
de lógica de primeira ordem no qual o universo contém funções e relações como objetos ou extender essa linguagem
para envolver novos tipos de quantificadores e variáveis, que é o caso descrito nessa sessão. Isto é o que Lógica
de Ordem mais Alta faz. 

Alonzo Church (1903 - 1995) foi um matemático e lógico estadunidense, conhecido pelo cálculo lambda, formulou a ideia
de ordens mais altas na lógica. Isso é algumas vezes descrito como Teoria Simples dos Tipos ou Teoria dos Tipos de 
Chunch's. Sejam $X, Y, Z,...$ tipos básicos e $Prop$ um tipo especial das proposições. Temos, então:
\begin{itemize}
    \item Se $X$ e $Y$ são tipos, então $U \times V$ também será.Isto denota que o par ordenado $(x,y)$, com $x \in X$ 
    e $y \in Y$ é tipado. 
    \item Se $X$ e $Y$ são tipos, então $U \to V$ também será.
\end{itemize}

Para formar expressões, a teoria de Church aficiona os seguintes caminhos: 
\begin{enumerate}
    \item Se $x$ é do tipo $X$ e $y$ é do tipo $Y$, $(x,y)$ é do tipo $X \times Y$. 
    \item Se $z$ é do tipo $X \times Y$, então $(p)_1$ é do tipo $X$ e $(p)_2$ é do tipo $Y$, que denotam o primeiro e 
    segundo elemento do par $z$, respectivamente. 
    \item Se $x$ é uma variável do tipo $X$ e $y$ é uma expressão do tipo $Y$, então $\lambda x y$ é do tipo $X \to Y$. 
    Para lembrar o significado dessa expressão, voltar em \ref{concept}.
    \item Se $f$ é do tipo $X \to Y$ e $x$ é do tipo $X$, $f(x)$ é do tipo $Y$. 
\end{enumerate}

Além desses meios, a teoria simples dos tipos possui conetivos booleanos, quantificadores e a igualdade, oriunda da lógica
de primeira ordem, para construir proposições. 

A fução $f(x,y)$ que toma elementos de $X$ e $Y$ para o tipo $Z$ é vista como um objeto do tipo $X \times Y \to Z$. Note que,
nesse sentido, uma relação binária $R(x,y)$ definida em $X$ e $Y$ é vista como um objeto $X \times Y \to Prop$. O que torma essa 
lógica ser de ordem mais alta é que podemos iterar o tipo função indefinidamente. Por exemplo, se $\mathbb{N}$ é o tipo dos números
naturais, $\mathbb{N} \to \mathbb{N}$ denota o tipo das funções dos números naturais aos números naturais, e $(\mathbb{N} \to \mathbb{N}) \to \mathbb{N}$ 
denota o tipo de funções $F(f)$ que tomam uma função como argumento e retornam um número natural. Vamos ver em Lean:

\begin{lstlisting}
open nat 

#check ℕ                -- ℕ : Type
#check ℕ → ℕ            -- ℕ → ℕ : Type
#check (ℕ → ℕ) → ℕ      -- (ℕ → ℕ) → ℕ : Type 

variable F: (ℕ → ℕ) → ℕ 
variable f: ℕ → ℕ
variable n: ℕ 

#check f n              -- f n : ℕ 
#check F f              -- F f : ℕ 
#check F n              -- error
\end{lstlisting}

A variavél $F$ espera uma função, por isso retorna erro no último \lstinline{#check}. Se retirarmos o parênteses, Lean entenderá que 
\lstinline{F : ℕ → (ℕ → ℕ)}. 

As especificações de síntaxe e regras da lógica de ordem mais alta são descritas mais cuidadosamente em livros-texto mais avançados. 
Para considerar os tipos de funções e relações, basta o conhecimento de lógica de segunda ordem. É importante ter em mente que já lidamos 
desde os primeiros capítulos com os tipos e lógica de segunda ordem, em Lean, que é um sistema de lógica ainda mais elaborado e expressivo. 

\subsection{Definindo a inversa Classicamente}

Para definir funções inversas, é necessário que utilizemos o racionínio clássico. 

\begin{lstlisting}
open classical 

#check @axiom_of_choice
#check @some_spec

variables A B : Type
variable P : A → Prop   
variable R : A → B → Prop

example : (∀ x, ∃ y, R x y) → ∃ f : A → B, ∀ x, R x (f x) :=
axiom_of_choice

example (h : ∃ x, P x) : P (some h) :=
some_spec h    
\end{lstlisting}

O axioma da escolha fala que se para todo \lstinline{x : X}, existe \lstinline{y: Y} com 
\lstinline{R x y}, então existe uma função \lstinline{f: X → Y} que para todo \lstinline{x},
escolhe-se \lstinline{y}. Em Lean, é utilizada a função \lstinline{some} para mostrar este a 
axioma, através da construção clássica. Podemos, portanto, definir a inversa como: 

\begin{lstlisting}
open classical function
local attribute [instance] prop_decidable

variables {X Y : Type}

noncomputable def inverse (f : X → Y) (default : X) : Y → X :=
λ y, if h : ∃ x, f x = y then some h else default   
\end{lstlisting}

Observe que a definição é não computacional, visto que como já argumentamos, para uma determinada função, essa 
hipótese \lstinline{h} pode não ser possível de validar algoritmicamente e, se a hipótese for válida, pode não 
ser possível encontrar um valor de \lstinline{x} adequado, também algoritmicamente. Também observe que essa inversa é 
definida assumindo \lstinline{y}, logo ela é definida para todo valor que ele assume e retorna algum valor qye cumpre 
essa propriedade \lstinline{f x = y}, quando a hipótese é válida, ou um valor padrão dado inicialmente, caso não exista. 
O comando \lstinline{local attribute} fala para a instância que a regra \lstinline{prop_decidable} vai ser utilizada no 
arquivo que se segue. Nesse caso, importamos os axiomas clássicos e tornamos disponível a instância genérica da decição.   

Podemos, então, demonstrar os seguintes teoremas. 

\begin{lstlisting}
open classical function
local attribute [instance] prop_decidable

variables {X Y : Type}

noncomputable def inverse (f : X → Y) (default : X) : Y → X :=
λ y, if h : ∃ x, f x = y then some h else default

theorem inverse_of_exists (f : X → Y) (default : X) (y : Y)
    (h : ∃ x, f x = y) : f (inverse f default y) = y :=
    have h₁ : inverse f default y = some h, from dif_pos h,
    have h₂ : f (some h) = y, from some_spec h,
eq.subst (eq.symm h₁) h₂

#check @dite
#check @dif_pos 

-- Using Term Mode 
theorem is_left_inverse_of_injective (f : X → Y) (default : X)
    (injf : injective f) : left_inverse (inverse f default) f :=
let finv := (inverse f default) in
    assume x,
    have h1 : ∃ x', f x' = f x, from exists.intro x rfl,
    have h2 : f (finv (f x)) = f x, 
        from inverse_of_exists f default (f x) h1,
    show finv (f x) = x, from injf h2

-- Using Tatic Mode 
theorem is_left_inverse_of_injective2 (f : X → Y) (default : X)
    (injf : injective f) : left_inverse (inverse f default) f :=
begin 
    intro x,
    apply injf, 
    apply inverse_of_exists,
    apply exists.intro x,
    exact eq.refl (f x), 
end
\end{lstlisting}

Observado o significado de \lstinline{dite}, que expressa a validade de um 
\lstinline{α : Sort}, independente de \lstinline{c: Prop} e o significado 
de \lstinline{dif_pos}, que expressa a igualdade entre uma expressão do formato 
\lstinline{dite} e outra do mesmo \lstinline{Sort}, podemos entender o siginificado
dessa prova. A versão em Táticas foi inserida como instrução de aplicação em comparação
como o modo em termos. 